import os
import logging
import json
import openai
import difflib
import re
from collections import defaultdict
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, MessageHandler, ContextTypes, filters, CommandHandler, CallbackQueryHandler

# –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è GPT –∫–ª—é—á–∞ —Ç–∞ –ø—Ä–æ–º–ø—Ç–∞
openai.api_key = os.getenv("OPENAI_API_KEY")
SYSTEM_PROMPT = os.getenv("SYSTEM_PROMPT", "–¢–∏ ‚Äî —é—Ä–∏–¥–∏—á–Ω–∏–π –ø–æ–º—ñ—á–Ω–∏–∫. –í—ñ–¥–ø–æ–≤—ñ–¥–∞–π –ª–∏—à–µ –∑–≥—ñ–¥–Ω–æ –∑ –±–∞–∑–æ—é —à–ø–æ—Ä–∏.")

# –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±–∞–∑–∏ —à–ø–æ—Ä–∏ –∑ JSON
with open("tdp_answers_full_structured.json", "r", encoding="utf-8") as f1, open("tdp_practical_answers.json", "r", encoding="utf-8") as f2 as f:
    answers = json.load(f1)
    practicals = json.load(f2)
    answers.update(practicals)

# –°–ø–∏—Å–æ–∫ –∫–ª—é—á—ñ–≤
keys = list(answers.keys())

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—ñ–≤
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –ö–æ–º–∞–Ω–¥–∞ /topics
async def topics_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["topics_page"] = 0
    await send_topics_page(update, context)

async def send_topics_page(update: Update, context: ContextTypes.DEFAULT_TYPE):
    page = context.user_data.get("topics_page", 0)
    topic_keys = [k for k in keys if not k.lower().startswith("–ø—Ä–∞–∫—Ç–∏—á–Ω–µ –∑–∞–≤–¥–∞–Ω–Ω—è ‚Ññ")]
    per_page = 10
    start = page * per_page
    end = start + per_page
    page_keys = topic_keys[start:end]

    keyboard = [[InlineKeyboardButton(text=k.title(), callback_data=str(keys.index(k)))] for k in page_keys]

    nav_buttons = []
    if start > 0:
        nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è –ü–æ–ø–µ—Ä–µ–¥–Ω—è", callback_data="topics_prev"))
    if end < len(topic_keys):
        nav_buttons.append(InlineKeyboardButton("‚û°Ô∏è –ù–∞—Å—Ç—É–ø–Ω–∞", callback_data="topics_next"))
    if nav_buttons:
        keyboard.append(nav_buttons)

    markup = InlineKeyboardMarkup(keyboard)
    if update.message:
        await update.message.reply_text("–û–±–µ—Ä—ñ—Ç—å —Ç–µ–º—É –∑ —à–ø–æ—Ä–∏:", reply_markup=markup)
    elif update.callback_query:
        await update.callback_query.edit_message_text("–û–±–µ—Ä—ñ—Ç—å —Ç–µ–º—É –∑ —à–ø–æ—Ä–∏:", reply_markup=markup)

# –ö–æ–º–∞–Ω–¥–∞ /practice ‚Äî –ø–æ–∫–∞–∑—É—î –ø—Ä–∞–∫—Ç–∏—á–Ω—ñ –∑–∞–≤–¥–∞–Ω–Ω—è
async def practice_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["practice_page"] = 0
    await send_practice_page(update, context)

async def send_practice_page(update: Update, context: ContextTypes.DEFAULT_TYPE):
    page = context.user_data.get("practice_page", 0)
    practice_keys = [k for k in keys if k.lower().startswith("–ø—Ä–∞–∫—Ç–∏—á–Ω–µ –∑–∞–≤–¥–∞–Ω–Ω—è ‚Ññ")]
    per_page = 10
    start = page * per_page
    end = start + per_page
    page_keys = practice_keys[start:end]

    keyboard = [[InlineKeyboardButton(text=k.title(), callback_data=str(keys.index(k)))] for k in page_keys]

    nav_buttons = []
    if start > 0:
        nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è –ü–æ–ø–µ—Ä–µ–¥–Ω—è", callback_data="practice_prev"))
    if end < len(practice_keys):
        nav_buttons.append(InlineKeyboardButton("‚û°Ô∏è –ù–∞—Å—Ç—É–ø–Ω–∞", callback_data="practice_next"))
    if nav_buttons:
        keyboard.append(nav_buttons)

    markup = InlineKeyboardMarkup(keyboard)
    if update.message:
        await update.message.reply_text("–û–±–µ—Ä—ñ—Ç—å –ø—Ä–∞–∫—Ç–∏—á–Ω–µ –∑–∞–≤–¥–∞–Ω–Ω—è:", reply_markup=markup)
    elif update.callback_query:
        await update.callback_query.edit_message_text("–û–±–µ—Ä—ñ—Ç—å –ø—Ä–∞–∫—Ç–∏—á–Ω–µ –∑–∞–≤–¥–∞–Ω–Ω—è:", reply_markup=markup)

# –î–æ–¥–∞—Ç–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –ø–∞–≥—ñ–Ω–∞—Ü—ñ—ó –¥–ª—è –∫–Ω–æ–ø–æ–∫
async def handle_topic_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "practice_next":
        context.user_data["practice_page"] = context.user_data.get("practice_page", 0) + 1
        await send_practice_page(update, context)
        return
    elif query.data == "practice_prev":
        context.user_data["practice_page"] = max(context.user_data.get("practice_page", 0) - 1, 0)
        await send_practice_page(update, context)
        return
    elif query.data == "topics_next":
        context.user_data["topics_page"] = context.user_data.get("topics_page", 0) + 1
        await send_topics_page(update, context)
        return
    elif query.data == "topics_prev":
        context.user_data["topics_page"] = max(context.user_data.get("topics_page", 0) - 1, 0)
        await send_topics_page(update, context)
        return
    elif query.data == "practice_prev":
        context.user_data["practice_page"] = max(context.user_data.get("practice_page", 0) - 1, 0)
        await send_practice_page(update, context)
        return

    try:
        index = int(query.data)
        key = keys[index]
        data = answers[key]
        reply = f"‚ùì <b>{data['–ø–∏—Ç–∞–Ω–Ω—è']}</b>

‚úÖ {data['–≤—ñ–¥–ø–æ–≤—ñ–¥—å']}"
        if data["–∑–∞–∫–æ–Ω–∏"]:
            reply += "

üìò <b>–ó–∞–∫–æ–Ω(–∏):</b> " + "; ".join(data["–∑–∞–∫–æ–Ω–∏"])
    except (ValueError, IndexError, KeyError):
        reply = "‚ùó –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –∫–Ω–æ–ø–∫–∏."
    await query.message.reply_text(reply, parse_mode="HTML")

# –ö–æ–º–∞–Ω–¥–∞ /laws ‚Äî –ø–æ–∫–∞–∑—É—î –∑–∞–∫–æ–Ω–∏ –∑–≥—Ä—É–ø–æ–≤–∞–Ω–æ
async def laws_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    categories = defaultdict(list)
    for value in answers.values():
        for law in value.get("–∑–∞–∫–æ–Ω–∏", []):
            if "–ö–æ–Ω—Å—Ç–∏—Ç—É—Ü" in law:
                categories["–ö–æ–Ω—Å—Ç–∏—Ç—É—Ü—ñ—è –£–∫—Ä–∞—ó–Ω–∏"].append(law)
            elif "–ö–æ–¥–µ–∫—Å" in law:
                categories["–ö–æ–¥–µ–∫—Å–∏ –£–∫—Ä–∞—ó–Ω–∏"].append(law)
            elif "–ó–∞–∫–æ–Ω" in law:
                categories["–ó–∞–∫–æ–Ω–∏ –£–∫—Ä–∞—ó–Ω–∏"].append(law)
            else:
                categories["–Ü–Ω—à—ñ"].append(law)

    if categories:
        reply = "üìò <b>–ó–∞–∫–æ–Ω–æ–¥–∞–≤—á—ñ –¥–∂–µ—Ä–µ–ª–∞, –∑–≥—Ä—É–ø–æ–≤–∞–Ω—ñ –∑–∞ —Ç–∏–ø–æ–º:</b>\n"
        for group, items in categories.items():
            laws = sorted(set(items))
            reply += f"\n<b>{group}:</b>\n" + "\n".join(f"‚ñ™Ô∏è {law}" for law in laws) + "\n"
    else:
        reply = "‚ö†Ô∏è –£ —à–ø–æ—Ä—ñ –Ω–µ –≤–∏—è–≤–ª–µ–Ω–æ –∑–≥–∞–¥–æ–∫ –ø—Ä–æ –∑–∞–∫–æ–Ω–∏."
    await update.message.reply_text(reply, parse_mode="HTML")

# –û–±—Ä–æ–±–∫–∞ –∫–Ω–æ–ø–æ–∫ —Ç–µ–º
async def handle_topic_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    try:
        index = int(query.data)
        key = keys[index]
        data = answers[key]
        reply = f"‚ùì <b>{data['–ø–∏—Ç–∞–Ω–Ω—è']}</b>\n\n‚úÖ {data['–≤—ñ–¥–ø–æ–≤—ñ–¥—å']}"
        if data["–∑–∞–∫–æ–Ω–∏"]:
            reply += "\n\nüìò <b>–ó–∞–∫–æ–Ω(–∏):</b> " + "; ".join(data["–∑–∞–∫–æ–Ω–∏"])
    except (ValueError, IndexError, KeyError):
        reply = "‚ùó –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –∫–Ω–æ–ø–∫–∏."
    await query.message.reply_text(reply, parse_mode="HTML")

# –í–∏—Ç—è–≥–∞–Ω–Ω—è –ø–æ—Å–∏–ª–∞–Ω—å –Ω–∞ –∑–∞–∫–æ–Ω–∏ –∑ GPT-–≤—ñ–¥–ø–æ–≤—ñ–¥—ñ
def extract_laws_from_text(text):
    pattern = r"—Å—Ç\.\s?\d+[^.\n]*?(–ö–æ–Ω—Å—Ç–∏—Ç—É—Ü|–ö–æ–¥–µ–∫—Å|–ó–∞–∫–æ–Ω)[^.,\n]*"
    matches = re.findall(pattern, text, flags=re.IGNORECASE)
    unique = sorted(set(matches))
    return unique

# –û–±—Ä–æ–±–∫–∞ –≤—Ö—ñ–¥–Ω–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_message = update.message.text.lower().strip()

    # –ü–æ—à—É–∫ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ –∫–ª—é—á–∞ —É —Å–ª–æ–≤–Ω–∏–∫—É
    best_match = difflib.get_close_matches(user_message, keys, n=1, cutoff=0.5)

    if best_match:
        data = answers[best_match[0]]
        reply = f"‚ùì <b>{data['–ø–∏—Ç–∞–Ω–Ω—è']}</b>\n\n‚úÖ {data['–≤—ñ–¥–ø–æ–≤—ñ–¥—å']}"
        if data["–∑–∞–∫–æ–Ω–∏"]:
            reply += "\n\nüìò <b>–ó–∞–∫–æ–Ω(–∏):</b> " + "; ".join(data["–∑–∞–∫–æ–Ω–∏"])
    else:
        # GPT fallback + –ø–æ—à—É–∫ –∑–∞–∫–æ–Ω—ñ–≤
        try:
            client = openai.OpenAI()
            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": SYSTEM_PROMPT},
                    {"role": "user", "content": user_message}
                ]
            )
            gpt_text = response.choices[0].message.content
            laws = extract_laws_from_text(gpt_text)
            reply = f"‚úÖ {gpt_text}"
            if laws:
                reply += "\n\nüìò <b>–ó–≥–∞–¥–∞–Ω–æ –∑–∞–∫–æ–Ω(–∏):</b> " + "; ".join(laws)
        except Exception as e:
            reply = "üîç –ù–µ–º–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ —É —à–ø–æ—Ä—ñ, —ñ GPT –Ω–µ –∑–º—ñ–≥ –≤—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏."

    await update.message.reply_text(reply, parse_mode="HTML")

async def search_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = " ".join(context.args).lower()
    matches = [k for k in keys if query in k.lower()]

    if not matches:
        await update.message.reply_text("‚ùå –ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
        return

    keyboard = [[InlineKeyboardButton(text=m.title(), callback_data=str(keys.index(m)))] for m in matches[:30]]
    markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"üîé –ó–Ω–∞–π–¥–µ–Ω–æ {len(matches)} —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤:", reply_markup=markup)

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
if __name__ == '__main__':
    telegram_token = os.getenv("TELEGRAM_TOKEN")
    if not telegram_token:
        raise ValueError("TELEGRAM_TOKEN –Ω–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–π!")

    app = ApplicationBuilder().token(telegram_token).build()
    app.add_handler(CommandHandler("topics", topics_command))
    app.add_handler(CommandHandler("laws", laws_command))
    app.add_handler(CommandHandler("practice", practice_command))
    app.add_handler(CommandHandler("search", search_command))
    app.add_handler(CallbackQueryHandler(handle_topic_callback))
    app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_message))

    print("üü¢ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω–æ. –û—á—ñ–∫—É—é –Ω–∞ –ø–∏—Ç–∞–Ω–Ω—è...")
    app.run_polling()
